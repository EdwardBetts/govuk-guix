#!/usr/bin/guile --no-auto-compile
-*- scheme -*-
!#

;; To allow this script to be run directly, even from the Git
;; repository, check if the environment is setup by checking if the
;; (gds services) module is loadable. If it's not loadable, start this
;; script again, but use the guix-pre-inst-env helper to setup the
;; environment.
(catch
  #t
  (lambda ()
    (resolve-interface '(gds services)))
  (lambda args
    (exit
     (status:exit-val
      (apply
       system*
       "bash"
       (string-append (dirname (dirname (current-filename)))
                      "/guix-pre-inst-env")
       "guile"
       (current-filename)
       (cdr (command-line)))))))

(use-modules
 (srfi srfi-1)
 (srfi srfi-11)
 (srfi srfi-19)
 (srfi srfi-37)
 (ice-9 match)
 (guix ui)
 (guix scripts)
 (gnu services)
 (gnu system)
 (gds services govuk)
 (gds services utils databases mysql)
 (gds services utils databases mongodb)
 (gds services utils databases postgresql)
 (gds systems govuk development)
 (gds data data-source)
 (gds data data-extract)
 (gds data govuk sources govuk-puppet))

(define data-sources
  (list govuk-puppet-data-source))

(define (all-extracts)
  (concatenate
   (filter-map
    (match-lambda (($ <data-source> list-extracts)
                   (list-extracts)))
    data-sources)))

(define (parse-date str)
  (string->date str "~d/~m/~Y"))

(define options
  ;; Specifications of the command-line options.
  (list (option '("database") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'database
                              arg
                              result)))
        (option '("before") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'before
                              (parse-date arg)
                              result)))
        (option '("after") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'after
                              (parse-date arg)
                              result)))))

(define (list-available-extracts . args)
  (let-values
      (((services data-extracts)
        (arguments->services-and-data-extracts args)))
    (for-each
     (match-lambda
      ((service-type . data-extracts)
       (if (member service-type (map service-kind services))
           (begin
             (simple-format #t "service: ~A\n" (service-type-name
                                                service-type))
             (for-each
              (match-lambda
               ((database . data-extracts)
                (simple-format #t "  database: ~A\n" database)
                (for-each
                 (lambda (data-extract)
                   (simple-format
                    #t "    - ~A\n"
                    (date->string (data-extract-datetime data-extract)
                                  "~d/~m/~Y")))
                 data-extracts)))
              (group-extracts data-extract-database data-extracts))))))
     (stable-sort
      (group-extracts data-extract-services
                      (sort-extracts data-extracts))
      (match-lambda* (((service-type1 . data-extracts1)
                       (service-type2 . data-extracts2))
                      (string<? (symbol->string
                                 (service-type-name service-type1))
                                (symbol->string
                                 (service-type-name service-type2)))))))))

(define (arguments->services-and-data-extracts args)
  (let* ((opts (parse-command-line args options '(())))
         (service-names
          (filter-map (match-lambda
                       (('argument . a) a)
                       (_ #f))
                      opts))
         (databases
          (filter-map (match-lambda
                       (('database . d) d)
                       (_ #f))
                      opts))
         (services (get-services service-names))
         (service-types (map service-kind services))
         (data-extracts
          (filter-extracts
           (all-extracts)
           #:service-types service-types
           #:databases (if (null? databases) #f databases)
           #:before-date (assq-ref opts 'before)
           #:after-date (assq-ref opts 'after))))
    (values services data-extracts)))

(define (get-services service-names)
  (let ((all-services
         ;; TODO: Maybe this wants to be the services from a
         ;; particular system instead?
         (operating-system-user-services development-os)))
    (if (null? service-names)
        all-services
        (map
         (lambda (service-name)
           (or
            (find (lambda (service)
                    (equal?
                     (string->symbol service-name)
                     (service-type-name (service-kind service))))
                  all-services)
            (leave (_ "Could not find service with name ~A")
                   service-name)))
         service-names))))

(define (database-connection-config service extract)
  (find
   (or
    (assoc-ref
     `(("postgresql" . ,postgresql-connection-config?)
       ("mongo"      . ,mongodb-connection-config?)
       ("mysql"      . ,mysql-connection-config?))
     (data-extract-database extract))
    (error "Unrecognised database type ~A" (data-extract-database extract)))
   (service-parameters service)))

(define (get-extracts-and-database-connection-configs services extracts)
  (define (missing-connection-error service extract)
    (display (service-parameters service))
    (error
     "Couldn't find a database connection configuration for ~A for the ~A service"
     (data-extract-database extract)
     (service-type-name (service-kind service))))

  (concatenate
   (map
    (lambda (service)
      (let ((service-extracts (filter-extracts
                               extracts
                               #:service-types (list
                                                (service-kind
                                                 service)))))
        (map
         (match-lambda
          ((database . extracts)
           ;; The appropriate extract is always last in the list due
           ;; to sorting
           (let ((extract (last (sort-extracts extracts))))
             (cons extract
                   (list
                    (or
                     (database-connection-config service extract)
                     (missing-connection-error service extract)))))))
         (group-extracts data-extract-database service-extracts))))
    services)))

(define (load . args)
  (let-values
      (((services data-extracts)
        (arguments->services-and-data-extracts args)))
    (map
     (match-lambda
      ((data-extract . database-connection-configs)
       (for-each
        (lambda (database-connection-config)
          (match data-extract
                 (($ <data-extract> file datetime database services)
                  (simple-format #t "Importing extract from ~A in to ~A\n"
                                 (date->string datetime "~d/~m/~Y")
                                 database)))
          (display "\n")
          (load-extract data-extract database-connection-config))
        database-connection-configs)))
     (get-extracts-and-database-connection-configs services
                                                   data-extracts))))

(define (govuk-data . args)
  (define commands
    `(("list" . ,list-available-extracts)
      ("load" . ,load)))

  (display "\n")
  (with-error-handling
    (if (= (length args) 1)
        (leave (_ "no command specified"))
        (let* ((command (second args))
               (handler
                (assoc-ref commands command)))
          (if handler
              (apply handler (cddr args))
              (leave (_ "command ~A is not recognised") command))))))

(apply govuk-data (command-line))
