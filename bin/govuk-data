#!/usr/bin/guile --no-auto-compile
-*- scheme -*-
!#

;; To allow this script to be run directly, even from the Git
;; repository, check if the environment is setup by checking if the
;; (gds services) module is loadable. If it's not loadable, start this
;; script again, but use the guix-pre-inst-env helper to setup the
;; environment.
(catch
  #t
  (lambda ()
    (resolve-interface '(gds services)))
  (lambda args
    (let* ((govuk-guix-root
            (or (and=> (current-filename)
                       (lambda (x)
                         (dirname (dirname x))))
                (getenv "GOVUK_GUIX_ROOT")
                (error "Unable to locate the govuk-guix root")))
           (command-full-path
            (string-append govuk-guix-root "/bin/govuk-data")))
      (exit
       (status:exit-val
        (apply
         system*
         "bash"
         (string-append govuk-guix-root "/guix-pre-inst-env")
         "guile"
         command-full-path
         (cdr (command-line))))))))

(use-modules
 (srfi srfi-1)
 (srfi srfi-11)
 (srfi srfi-19)
 (srfi srfi-37)
 (ice-9 match)
 (ice-9 format)
 (guix ui)
 (guix scripts)
 (gnu services)
 (gnu system)
 (gds utils)
 (gds services govuk)
 (gds services utils databases)
 (gds services utils databases mysql)
 (gds services utils databases mongodb)
 (gds services utils databases postgresql)
 (gds services utils databases elasticsearch)
 (gds systems govuk development)
 (gds data data-source)
 (gds data data-extract)
 (gds data govuk sources govuk-puppet))

(define data-sources
  (list govuk-puppet-data-source))

(define (all-extracts)
  (append-map
   (lambda (list-extracts-thunk) (list-extracts-thunk))
   (map data-source-list-extracts data-sources)))

(define (parse-date str)
  (string->date str "~d/~m/~Y"))

(define options
  ;; Specifications of the command-line options.
  (list (option '("database") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'database
                              arg
                              result)))
        (option '("before") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'before
                              (parse-date arg)
                              result)))
        (option '("after") #t #f
                (lambda (opt name arg result)
                  (alist-cons 'after
                              (parse-date arg)
                              result)))
        (option '("dry-run") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'dry-run? #t result)))))

(define (list-available-extracts . args)
  (let-values
      (((services data-extracts)
        (options->services-and-data-extracts
         (parse-command-line args options '(())))))
    (for-each
     (match-lambda
      ((service-type . data-extracts)
       (if (member service-type (map service-kind services))
           (begin
             (simple-format #t "service: ~A\n" (service-type-name
                                                service-type))
             (for-each
              (match-lambda
               ((database . data-extracts)
                (simple-format #t "  database: ~A\n" database)
                (for-each
                 (match-lambda
                  ((date . data-extracts)
                   (simple-format
                    #t "    - ~A\n"
                    (date->string date "~d/~m/~Y"))
                   (if (> (length data-extracts) 1)
                       (for-each
                        (lambda (data-extract)
                          (let ((data-source
                                 (data-extract-data-source
                                  data-extract)))
                            (format
                             #t
                             "      - ~A (~:r priority)\n"
                             (data-source-name data-source)
                             (data-source-priority data-source))))
                        data-extracts))))
                 (group-extracts data-extract-datetime data-extracts))))
              (group-extracts data-extract-database data-extracts))))))
     (stable-sort
      (group-extracts data-extract-services
                      (sort-extracts data-extracts))
      (match-lambda* (((service-type1 . data-extracts1)
                       (service-type2 . data-extracts2))
                      (string<? (symbol->string
                                 (service-type-name service-type1))
                                (symbol->string
                                 (service-type-name service-type2)))))))))

(define (options->services-and-data-extracts opts)
  (let* ((service-names
          (filter-map (match-lambda
                       (('argument . a) a)
                       (_ #f))
                      opts))
         (databases
          (filter-map (match-lambda
                       (('database . d) d)
                       (_ #f))
                      opts))
         (services (get-services service-names))
         (service-types (map service-kind services))
         (data-extracts
          (filter-extracts
           (all-extracts)
           #:service-types (if (null? service-types)
                               #f
                               service-types)
           #:databases (if (null? databases) #f databases)
           #:before-date (assq-ref opts 'before)
           #:after-date (assq-ref opts 'after))))
    (values services data-extracts)))

(define (get-services service-names)
  (let ((all-services
         ;; TODO: Maybe this wants to be the services from a
         ;; particular system instead?
         (operating-system-user-services development-os)))
    (if (null? service-names)
        all-services
        (map
         (lambda (service-name)
           (or
            (find (lambda (service)
                    (eq?
                     (string->symbol service-name)
                     (service-type-name (service-kind service))))
                  all-services)
            (leave (G_ "Could not find service with name ~A")
                   service-name)))
         service-names))))

(define (database-connection-config-from-service-for-extract service extract)
  (or
   (find
    (or
     (assoc-ref
      `(("postgresql"    . ,postgresql-connection-config?)
        ("mongo"         . ,mongodb-connection-config?)
        ("mysql"         . ,mysql-connection-config?)
        ("elasticsearch" . ,elasticsearch-connection-config?))
      (data-extract-database extract))
     (error "Unrecognised database type ~A" (data-extract-database extract)))
    (service-parameters service))
   (begin
     (display (service-parameters service))
     (error
      "Couldn't find a database connection configuration for ~A for the ~A service"
      (data-extract-database extract)
      (service-type-name (service-kind service))))))

(define (get-extracts-and-database-connection-configs services extracts)
  (fold
   (lambda (service data-extracts-and-database-connection-configs)
     (let ((service-extracts (filter-extracts
                              extracts
                              #:service-types (list
                                               (service-kind
                                                service)))))
       (fold
        (match-lambda*
          (((database . extracts) data-extracts-and-database-connection-configs)
           ;; The appropriate extract is always last in the list due
           ;; to sorting
           (let ((extract (last (sort-extracts extracts))))
             (alist-add
              extract
              (database-connection-config-from-service-for-extract service
                                                                   extract)
              data-extracts-and-database-connection-configs))))
        data-extracts-and-database-connection-configs
        (group-extracts data-extract-database service-extracts))))
   '()
   services))

(define (show-selected-extracts extracts-and-database-connection-configs)
  (display "Extracts selected:\n")
  (map
   (match-lambda
     ((data-extract . database-connection-configs)
      (for-each
       (lambda (database-connection-config)
         (match data-extract
           (($ <data-extract> file datetime database services data-source)
            (simple-format
             #t " - ~A extract from ~A (~A) into the ~A database for"
             database
             (date->string datetime "~d/~m/~Y")
             (data-source-name data-source)
             (match database
               ("elasticsearch" "elasticsearch")
               (else
                (database-connection-config->database-name
                 database-connection-config))))
            (if (eq? 1 (length services))
                (simple-format #t " the ~A service\n"
                               (service-type-name (first services)))
                (begin
                  (display ":\n")
                  (for-each
                   (lambda (service)
                     (simple-format #t "   - ~A\n"
                                    (service-type-name service)))
                   services))))))
       database-connection-configs)))
   extracts-and-database-connection-configs)
  (display "\n"))

(define* (load-selected-extracts
          extracts-and-database-connection-configs
          #:key dry-run?)
  (map
   (match-lambda
     ((data-extract . database-connection-configs)
      (for-each
       (lambda (database-connection-config)
         (match data-extract
           (($ <data-extract> file datetime database services)
            (simple-format
             #t "Importing extract from ~A in to ~A\n"
             (date->string datetime "~d/~m/~Y")
             (match database
               ("elasticsearch" "elasticsearch")
               (else (database-connection-config->database-name
                      database-connection-config))))))
         (display "\n")
         (load-extract data-extract database-connection-config
                       #:dry-run? dry-run?))
       database-connection-configs)))
   extracts-and-database-connection-configs))

(define (load . args)
  (let ((options (parse-command-line args options '(()))))
    (let-values
        (((services data-extracts)
          (options->services-and-data-extracts options)))
      (let ((extracts-and-database-connection-configs
             (get-extracts-and-database-connection-configs services
                                                           data-extracts)))
        (show-selected-extracts extracts-and-database-connection-configs)
        (load-selected-extracts extracts-and-database-connection-configs
                                #:dry-run? (assq-ref options 'dry-run?))))))

(define (govuk-data . args)
  (define commands
    `(("list" . ,list-available-extracts)
      ("load" . ,load)))

  (display "\n")
  (with-error-handling
    (if (= (length args) 1)
        (leave (G_ "no command specified"))
        (let* ((command (second args))
               (handler
                (assoc-ref commands command)))
          (if handler
              (apply handler (cddr args))
              (leave (G_ "command ~A is not recognised") command))))))

(apply govuk-data (command-line))
