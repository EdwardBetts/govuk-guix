#!/usr/bin/env ruby

require 'etc'
require 'uri'
require 'json'
require 'open3'
require 'optparse'
require 'fileutils'

def data_directory_base_url
  ENV['GOVUK_GUIX_DATA_DIRECTORY_BASE_URL'] || 's3://govuk-development-data-test'
end

def cache_directory
  base = ENV['XDG_CACHE_HOME'] || "#{ENV['HOME']}/.cache"

  "#{base}/govuk-guix/development-data"
end

def aws_s3(*args)
  status = system(*(%w[govuk aws --profile govuk-integration -- s3] + args))

  unless status
    STDERR.puts "error: aws s3 command failed: #{args.join(' ')}"
    exit 1
  end
end

def data_storage_directory
  if Dir.exists? '/var/govuk'
    directory = '/var/govuk/development-data'
  elsif Dir.exists? "#{ENV['HOME']}/govuk"
    directory = "#{ENV['HOME']}/govuk/development-data"
  else
    directory = "#{cache_directory}"
  end

  FileUtils.mkdir_p directory
  directory
end

def retrieve_index
  base_uri = URI(data_directory_base_url)

  case base_uri.scheme
  when "file"
    data_extracts_index = "#{base_uri.path}data-extracts/index.json"
    JSON.parse(File.read(data_extracts_index))
  when "s3"
    aws_s3('cp', "#{data_directory_base_url}/data-extracts/index.json", "#{cache_directory}/data-extracts/")
    JSON.parse(File.read("#{cache_directory}/data-extracts/index.json"))
  when "http"
  when "https"
  when "ssh"
    raise "#{base_uri.scheme} not yet supported"
  else
    puts "error: unrecognised URI scheme #{base_uri.scheme}"
  end
end

def get_local_path_to_extract_data(extract, dry_run)
  extract_data_uri = URI(
    File.join(data_directory_base_url, 'data-extracts', extract[:url])
  )

  case extract_data_uri.scheme
  when "file"
    extract_data_uri.path
  when "s3"
    storage_directory = data_storage_directory
    resulting_filename = File.join(storage_directory, File.basename(extract[:url]))

    unless File.exist?(resulting_filename)
      if dry_run
        puts "would download #{extract_data_uri} to #{storage_directory}/"
      else
        puts "downloading #{extract_data_uri} to #{storage_directory}/\n"
        aws_s3('cp', extract_data_uri.to_s, "#{storage_directory}/")
      end
    else
      puts "using existing file for #{extract_data_uri}"
    end

    resulting_filename
  when "http"
  when "https"
  when "ssh"
    raise "#{base_uri.scheme} not yet supported"
  else
    STDERR.puts "error: unrecognised URI scheme #{base_uri.scheme}"
    exit 1
  end
end

def retrieve_extracts
  index_data = retrieve_index

  index_data['extracts'].map do |extract_hash|
    extract_hash.each_with_object({}) do |(key, value), result|
      result[key.to_sym] = value
    end
  end
end

def group_extracts(field, extracts)
  extracts.each_with_object(Hash.new { |h,k| h[k] = [] }) do |extract, result|
    key = extract[field]
    if key.kind_of?(Hash)
      key = key.keys
    elsif !key.kind_of?(Array)
      key = [key]
    end

    key.each do |key_value|
      result[key_value].push(extract)
    end
  end
end

def sort_extracts(extracts)
  extracts.sort_by { |extract| extract[:date] }
end

FILTER_OPTIONS = %i(services database before_date after_date).freeze

def filter_extracts(extracts,
                    services: false,
                    database: false,
                    before_date: false,
                    after_date: false)
  extracts.select do |extract|
    next if services and
      services.all? { |service| !extract[:services].keys.include? service }

    next if database and !database.include? extract[:database]
    next if before_date and extract[:before_date] > before_date
    next if after_date and extract[:after_date] < after_date

    true
  end
end

def all_services(extracts)
  extracts.map(&:services).map(&:keys).flatten.unique
end

def list(options)
  extracts = filter_extracts(
    retrieve_extracts,
    **options.keep_if { |k| FILTER_OPTIONS.include? k }
  )

  group_extracts(:services, extracts).each do |service, extracts|
    puts "service: #{service}"
    group_extracts(:database, extracts).each do |database, extracts|
      puts "  database: #{database}"
      extracts.each do |extract|
        puts "    - #{extract[:date]}"
      end
    end
  end
end

def extracts_to_load_by_service_and_database(extracts)
  group_extracts(
    :services, extracts
  ).each_with_object({}) do |(service, extracts), result|
    result[service] = begin
      group_extracts(
        :database, extracts
      ).each_with_object({}) do |(database, extracts), result|
        # The last extract is the desired one, due to the sorting
        result[database] = sort_extracts(extracts).last
      end
    end
  end
end

def show_extracts_to_load(extracts_by_service_and_database)
  puts "Extracts selected:"
  extracts_by_service_and_database.each do |service, extracts_by_database|
    extracts_by_database.each do |database, extract|
      puts " - #{database} extract from #{extract[:date]} into the #{service} database"
    end
  end
end

def get_decompressor(filename)
  if filename.end_with? 'xz'
    'xz'
  elsif filename.end_with? 'gz'
    'gzip'
  end
end

def load_postgresql_extract(extract, service, options)
  dry_run = options[:dry_run]
  local_file = get_local_path_to_extract_data(extract, dry_run)
  decompressor = get_decompressor(local_file)
  target_database = extract[:services][service]['database']
  if Etc.getlogin == 'vagrant'
    user = 'postgres'
    psql_command = "sudo -E -u postgres psql"
  else
    user = extract[:services][service]['user']
    psql_command = "psql"
  end
  if options[:for_govuk_guix_system]
    psql_command += " -U postgres --host=127.0.0.1 --port=#{extract[:services][service]['port']}"
  end

  commands = [
    "#{psql_command} -c \"DROP DATABASE IF EXISTS \\\"#{target_database}\\\"\"",
    "#{psql_command} -c \"CREATE DATABASE \\\"#{target_database}\\\"\"",
    "pv #{local_file} | #{decompressor} -d | #{psql_command} --no-psqlrc --quiet --user=#{user} #{target_database}"
  ]

  commands.each do |command|
    if dry_run
      puts "Would run command: #{command}"
    else
      puts "Running command: #{command}"
      unless system(command)
        STDERR.puts "error: creating #{target_database} failed"
        exit 1
      end
    end
  end

  alter_owner_queries = {
    table: "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';",
    view: "SELECT table_name FROM information_schema.views WHERE table_schema = 'public';",
    sequence: "SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public';"
  }

  alter_owner_queries.each do |type, query|
    command = "#{psql_command} -qXAt -c \"#{query}\" #{target_database}"
    object_names, status = Open3.capture2(command)

    unless status.success?
      STDERR.puts "error: command failed: #{command}"
      exit 1
    end

    object_names.each_line do |name|
      change_owner_command = "#{psql_command} -qXAt -c \"ALTER #{type.to_s.upcase} \\\"#{name.strip}\\\" OWNER TO vagrant\" #{target_database}"

      unless system(change_owner_command)
        STDERR.puts "error: command failed: #{change_owner_command}"
        exit 1
      end
    end
  end

  puts "\nSuccessfully created #{target_database}"
end

def load_mysql_extract(extract, service, options)
  dry_run = options[:dry_run]
  local_file = get_local_path_to_extract_data(extract, dry_run)
  decompressor = get_decompressor(local_file)
  target_database = extract[:services][service]['database']
  mysql_args = "-u root"
  if options[:for_govuk_guix_system]
    mysql_args += " --host=127.0.0.1 --port=#{extract[:services][service]['port']}"
  end
  puts extract[:services][service]

  commands = [
    "mysql #{mysql_args} -e \"DROP DATABASE IF EXISTS #{target_database}\"",
    "mysql #{mysql_args} -e \"CREATE DATABASE #{target_database}\"",
    "pv #{local_file} | #{decompressor} -d | mysql #{mysql_args} #{target_database}"
  ]

  commands.each do |command|
    if dry_run
      puts "Would run command: #{command}"
    else
      puts "Running command: #{command}"
      unless system(command)
        STDERR.puts "error: creating #{target_database} failed"
        exit 1
      end
    end
  end

  puts "\nSuccessfully created #{target_database}"
end

def load_mongo_extract(extract, service, dry_run)
  local_file = get_local_path_to_extract_data(extract, dry_run)
  target_database = extract[:services][service]['database']
  command = "mongorestore -d #{target_database} #{local_file}"

  if dry_run
    puts "Would run command: #{command}"
  else
    puts "Running command: #{command}"
    system(command)
  end
end

def load_extracts(extracts_by_service_and_database, options)
  dry_run = options[:dry_run]

  extracts_by_service_and_database.each do |service, extracts_by_database|
    extracts_by_database.each do |database, extract|
      puts "#{dry_run ? 'Would import' : 'Importing'} extract from #{extract[:date]} into the #{service} database"
      puts

      if database == "postgresql"
        load_postgresql_extract(extract, service, options)
      elsif database == "mysql"
        load_mysql_extract(extract, service, options)
      elsif database == "mongo"
        load_mongo_extract(extract, service, dry_run)
      else
        STDERR.puts "unknown database: #{database}"
        exit 1
      end
    end
  end
end

def load(options)
  all_extracts = filter_extracts(
    retrieve_extracts,
    **options.select { |k, _v| FILTER_OPTIONS.include? k }
  )

  services = options[:services] or all_services(all_extracts)

  extracts = extracts_to_load_by_service_and_database(all_extracts)

  show_extracts_to_load(extracts)
  puts

  load_extracts(extracts, options)
end

def fetch(options)
  all_extracts = filter_extracts(
    retrieve_extracts,
    **options.select { |k, _v| FILTER_OPTIONS.include? k }
  )

  extracts = extracts_to_load_by_service_and_database(all_extracts)

  show_extracts_to_load(extracts)
  puts

  extracts.each do |service, extracts_by_database|
    extracts_by_database.each do |database, extract|
      local_file = get_local_path_to_extract_data(extract, options[:dry_run])
      puts "govuk: data: finished fetching #{local_file}"
    end
  end
end

def check_prerequsites
  aws_config = "#{ENV['HOME']}/.aws/config"
  unless File.exist? aws_config
    STDERR.puts "error: #{aws_config} not found, see https://docs.publishing.service.gov.uk/manual/aws-cli-access.html for setup instructions"
    exit 1
  end
end

def parse_options
  options = {}

  OptionParser.new do |opt|
    opt.on('--database DATABASE') { |o| options[:database] = o }
    opt.on('--before BEFORE') { |o| options[:before_date] = o }
    opt.on('--after AFTER') { |o| options[:after_date] = o }
    opt.on('--dry-run') { |o| options[:dry_run] = true }
    opt.on('--for-govuk-guix-system') { |o| options[:for_govuk_guix_system] = true }
  end.parse!

  options
end

def main
  options = parse_options

  command = ARGV.shift
  options[:services] = ARGV if !ARGV.empty?
  unless command
    STDERR.puts "error: no command specified"
    exit 1
  end

  check_prerequsites

  case command
  when "list"
    list(options)
  when "load"
    load(options)
  when "fetch"
    fetch(options)
  else
    STDERR.puts "error: command #{command} is not recognised"
    exit 1
  end
end

main
